# Slice 7: Template Configuration and Validation

## Goal

Create a robust template configuration system with Pydantic models, comprehensive validation, and template loading from .spectemplate files with proper error handling and extensibility for AI integration.

## Context

The current monolithic code has basic template handling scattered throughout with minimal validation. This slice creates a sophisticated template configuration system using Pydantic for validation, supporting both file-based and default templates. It establishes the foundation for the template system that will be shared between cmd_gen and future git hooks, with clear extension points for AI content injection.

## Scope

**Included in this slice:**
- TemplateConfig Pydantic model with validation
- Template loading from .spectemplate files with YAML parsing
- Template validation with helpful error messages
- Variable placeholder validation and documentation
- Default template definitions with comprehensive structure

**NOT included in this slice:**
- Template content generation (comes in slice-8-template-generation)
- Variable substitution engine (comes in slice-8-template-generation)
- AI integration hooks (extension points defined but not implemented)

## Prerequisites

**Required modules that must exist:**
- `spec_cli.exceptions` (SpecError hierarchy for template errors)
- `spec_cli.logging.debug` (debug_logger for template operations)
- `spec_cli.config.settings` (SpecSettings for template file paths)
- `spec_cli.file_system.path_resolver` (PathResolver for template file handling)

**Required functions/classes:**
- All exception classes from slice-1-exceptions
- `debug_logger` from slice-2-logging
- `SpecSettings` and `get_settings()` from slice-3-configuration
- `PathResolver` from slice-4-path-resolution

**Required dependencies:**
- `pydantic` for data validation (already in dependencies)
- `PyYAML` for YAML parsing (already in dependencies)

## Files to Create

```
spec_cli/templates/
├── __init__.py             # Module exports
├── config.py               # TemplateConfig model and validation
├── loader.py               # Template loading from files
└── defaults.py             # Default template definitions
```

## Implementation Steps

### Step 1: Create spec_cli/templates/__init__.py

```python
"""Template system for spec CLI.

This package provides template configuration, loading, and content generation
for creating consistent documentation across different contexts.
"""

from .config import TemplateConfig, TemplateValidator
from .loader import TemplateLoader, load_template
from .defaults import get_default_template_config

__all__ = [
    "TemplateConfig",
    "TemplateValidator",
    "TemplateLoader",
    "load_template",
    "get_default_template_config",
]
```

### Step 2: Create spec_cli/templates/defaults.py

```python
"""Default template definitions for spec documentation."""

from typing import Dict, Any
from .config import TemplateConfig

# Default template content with comprehensive structure
DEFAULT_INDEX_TEMPLATE = """# {{filename}}

**Location**: `{{filepath}}`  
**Type**: {{file_type}}  
**Last Updated**: {{date}}

## Purpose

{{purpose}}

## Overview

{{overview}}

## Key Responsibilities

{{responsibilities}}

## Dependencies

{{dependencies}}

## API/Interface

{{api_interface}}

## Usage Examples

```{{file_extension}}
{{example_usage}}
```

## Configuration

{{configuration}}

## Error Handling

{{error_handling}}

## Testing

{{testing_notes}}

## Performance Considerations

{{performance_notes}}

## Security Considerations

{{security_notes}}

## Future Enhancements

{{future_enhancements}}

## Related Documentation

{{related_docs}}

## Notes

{{notes}}

---
*Generated by spec-cli on {{date}}*
"""

DEFAULT_HISTORY_TEMPLATE = """# History for {{filename}}

This file tracks the evolution, changes, and lessons learned for `{{filepath}}`.

## {{date}} - Initial Creation

**Context**: {{context}}

**Purpose**: {{initial_purpose}}

**Key Decisions**: {{decisions}}

**Implementation Notes**: {{implementation_notes}}

## Change Log

### Format
Each entry should include:
- **Date**: When the change occurred
- **Type**: [Feature|Bugfix|Refactor|Documentation|Performance|Security]
- **Description**: What changed and why
- **Impact**: How this affects the codebase
- **Lessons Learned**: What we learned from this change

---

## Templates for Future Entries

### Feature Addition
```
## YYYY-MM-DD - Feature: [Brief Description]

**Type**: Feature
**Description**: [Detailed description of the feature]
**Motivation**: [Why this feature was needed]
**Implementation**: [How it was implemented]
**Impact**: [Effects on the codebase, performance, etc.]
**Lessons Learned**: [What we learned during implementation]
```

### Bug Fix
```
## YYYY-MM-DD - Bugfix: [Brief Description]

**Type**: Bugfix
**Description**: [What bug was fixed]
**Root Cause**: [What caused the bug]
**Solution**: [How the bug was fixed]
**Prevention**: [How to prevent similar bugs]
**Lessons Learned**: [What we learned from this bug]
```

### Refactoring
```
## YYYY-MM-DD - Refactor: [Brief Description]

**Type**: Refactor
**Description**: [What was refactored]
**Motivation**: [Why the refactor was needed]
**Changes**: [What specifically changed]
**Benefits**: [Improvements gained]
**Lessons Learned**: [What we learned during refactoring]
```

---
*History maintained by spec-cli*
"""

def get_default_template_config() -> TemplateConfig:
    """Get the default template configuration.
    
    Returns:
        TemplateConfig with default templates
    """
    return TemplateConfig(
        index=DEFAULT_INDEX_TEMPLATE,
        history=DEFAULT_HISTORY_TEMPLATE
    )

def get_minimal_template_config() -> TemplateConfig:
    """Get a minimal template configuration for quick documentation.
    
    Returns:
        TemplateConfig with minimal templates
    """
    minimal_index = """# {{filename}}

**Location**: {{filepath}}  
**Purpose**: {{purpose}}

## Overview

{{overview}}

## Usage

```{{file_extension}}
{{example_usage}}
```

## Notes

{{notes}}
"""

    minimal_history = """# History for {{filename}}

## {{date}} - Initial Creation

**Purpose**: {{initial_purpose}}
**Context**: {{context}}
"""

    return TemplateConfig(
        index=minimal_index,
        history=minimal_history
    )

def get_comprehensive_template_config() -> TemplateConfig:
    """Get a comprehensive template configuration for detailed documentation.
    
    Returns:
        TemplateConfig with comprehensive templates
    """
    comprehensive_index = DEFAULT_INDEX_TEMPLATE + """

## Architecture

{{architecture}}

## Design Patterns

{{design_patterns}}

## Code Quality

{{code_quality}}

## Monitoring

{{monitoring}}

## Troubleshooting

{{troubleshooting}}

## Migration Guide

{{migration_guide}}
"""

    comprehensive_history = DEFAULT_HISTORY_TEMPLATE + """

## Detailed Analysis

### Architecture Evolution
{{architecture_evolution}}

### Performance Impact
{{performance_impact}}

### Security Implications
{{security_implications}}

### Technical Debt
{{technical_debt}}

### Future Planning
{{future_planning}}
"""

    return TemplateConfig(
        index=comprehensive_index,
        history=comprehensive_history
    )

# Template configurations registry
TEMPLATE_PRESETS = {
    "default": get_default_template_config,
    "minimal": get_minimal_template_config,
    "comprehensive": get_comprehensive_template_config,
}

def get_template_preset(preset_name: str) -> TemplateConfig:
    """Get a template configuration by preset name.
    
    Args:
        preset_name: Name of the preset ("default", "minimal", "comprehensive")
        
    Returns:
        TemplateConfig for the preset
        
    Raises:
        ValueError: If preset name is not recognized
    """
    if preset_name not in TEMPLATE_PRESETS:
        available = ", ".join(TEMPLATE_PRESETS.keys())
        raise ValueError(f"Unknown template preset '{preset_name}'. Available: {available}")
    
    return TEMPLATE_PRESETS[preset_name]()
```

### Step 3: Create spec_cli/templates/config.py

```python
from typing import Dict, Any, List, Set, Optional
from pydantic import BaseModel, Field, validator
from pathlib import Path
import re
from ..exceptions import SpecTemplateError
from ..logging.debug import debug_logger

class TemplateConfig(BaseModel):
    """Configuration for spec template generation with comprehensive validation."""
    
    index: str = Field(
        description="Template for index.md file content",
        min_length=10
    )
    
    history: str = Field(
        description="Template for history.md file content", 
        min_length=10
    )
    
    # Template metadata
    version: str = Field(default="1.0", description="Template version")
    description: Optional[str] = Field(default=None, description="Template description")
    author: Optional[str] = Field(default=None, description="Template author")
    
    # AI integration settings (extension points)
    ai_enabled: bool = Field(default=False, description="Enable AI content generation")
    ai_model: Optional[str] = Field(default=None, description="AI model to use")
    ai_temperature: float = Field(default=0.3, ge=0.0, le=1.0, description="AI creativity level")
    ai_max_tokens: int = Field(default=1000, ge=100, le=4000, description="Maximum AI tokens")
    
    # Template behavior settings
    preserve_manual_edits: bool = Field(default=True, description="Preserve manual edits during regeneration")
    include_timestamp: bool = Field(default=True, description="Include generation timestamp")
    include_metadata: bool = Field(default=True, description="Include file metadata")
    
    class Config:
        """Pydantic configuration."""
        validate_assignment = True
        extra = "forbid"  # Reject unknown fields
    
    @validator('index', 'history')
    def validate_template_syntax(cls, v: str, field: Any) -> str:
        """Validate template syntax and required placeholders."""
        if not v.strip():
            raise ValueError(f"{field.name} template cannot be empty")
        
        # Check for balanced braces
        open_count = v.count('{{')
        close_count = v.count('}}')
        if open_count != close_count:
            raise ValueError(f"{field.name} template has unmatched braces ({{ vs }})")
        
        # Check for required placeholders
        required_placeholders = ['{{filename}}']
        for placeholder in required_placeholders:
            if placeholder not in v:
                raise ValueError(f"{field.name} template must contain {placeholder} placeholder")
        
        # Validate placeholder syntax
        invalid_placeholders = re.findall(r'{[^{]|[^}]}', v)
        if invalid_placeholders:
            raise ValueError(f"{field.name} template has malformed placeholders: {invalid_placeholders}")
        
        return v
    
    @validator('ai_model')
    def validate_ai_model(cls, v: Optional[str], values: Dict[str, Any]) -> Optional[str]:
        """Validate AI model specification."""
        if v is not None and values.get('ai_enabled', False):
            # Basic validation - could be extended for specific model formats
            if not v.strip():
                raise ValueError("AI model cannot be empty when AI is enabled")
        return v
    
    def get_available_variables(self) -> Dict[str, str]:
        """Get all available template variables with descriptions.
        
        Returns:
            Dictionary mapping variable names to descriptions
        """
        return {
            # File information
            "filename": "Name of the source file",
            "filepath": "Full path to the source file relative to project root",
            "file_extension": "File extension without the dot (e.g., 'py', 'js')",
            "file_type": "Detected file type category (e.g., 'python', 'javascript')",
            
            # Timestamps
            "date": "Current date in YYYY-MM-DD format",
            "datetime": "Current date and time in ISO format",
            "timestamp": "Unix timestamp of generation",
            
            # Content placeholders (for AI or manual filling)
            "purpose": "Purpose and role of the file",
            "overview": "High-level overview of the file",
            "responsibilities": "Key responsibilities of the file",
            "dependencies": "Dependencies and requirements",
            "api_interface": "API or interface definition",
            "example_usage": "Example usage code",
            "configuration": "Configuration details",
            "error_handling": "Error handling approach",
            "testing_notes": "Testing guidelines and notes",
            "performance_notes": "Performance considerations",
            "security_notes": "Security considerations",
            "future_enhancements": "Planned future enhancements",
            "related_docs": "Links to related documentation",
            "notes": "Additional notes and comments",
            
            # History-specific placeholders
            "context": "Context for creation or changes",
            "initial_purpose": "Initial purpose when file was created",
            "decisions": "Key decisions made",
            "implementation_notes": "Implementation details and notes",
            
            # Advanced placeholders (for comprehensive templates)
            "architecture": "Architectural details",
            "design_patterns": "Design patterns used",
            "code_quality": "Code quality metrics and notes",
            "monitoring": "Monitoring and observability",
            "troubleshooting": "Troubleshooting guide",
            "migration_guide": "Migration and upgrade guide",
        }
    
    def get_placeholders_in_templates(self) -> Set[str]:
        """Extract all placeholders used in the templates.
        
        Returns:
            Set of placeholder names found in templates
        """
        placeholders = set()
        
        # Find all {{variable}} patterns
        pattern = re.compile(r'\{\{(\w+)\}\}')
        
        for template_content in [self.index, self.history]:
            matches = pattern.findall(template_content)
            placeholders.update(matches)
        
        return placeholders
    
    def validate_placeholders(self) -> List[str]:
        """Validate that all placeholders in templates are recognized.
        
        Returns:
            List of validation issues (empty if all valid)
        """
        used_placeholders = self.get_placeholders_in_templates()
        available_placeholders = set(self.get_available_variables().keys())
        
        issues = []
        
        # Check for unknown placeholders
        unknown = used_placeholders - available_placeholders
        if unknown:
            issues.append(f"Unknown placeholders: {', '.join(sorted(unknown))}")
        
        # Check for missing critical placeholders
        critical_placeholders = {'filename', 'filepath'}
        for template_name, template_content in [('index', self.index), ('history', self.history)]:
            template_placeholders = set(re.findall(r'\{\{(\w+)\}\}', template_content))
            missing_critical = critical_placeholders - template_placeholders
            if missing_critical:
                issues.append(f"{template_name} template missing critical placeholders: {', '.join(sorted(missing_critical))}")
        
        return issues
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert template config to dictionary for serialization."""
        return {
            "index": self.index,
            "history": self.history,
            "version": self.version,
            "description": self.description,
            "author": self.author,
            "ai_enabled": self.ai_enabled,
            "ai_model": self.ai_model,
            "ai_temperature": self.ai_temperature,
            "ai_max_tokens": self.ai_max_tokens,
            "preserve_manual_edits": self.preserve_manual_edits,
            "include_timestamp": self.include_timestamp,
            "include_metadata": self.include_metadata,
        }

class TemplateValidator:
    """Validates template configuration and provides detailed feedback."""
    
    def __init__(self):
        debug_logger.log("INFO", "TemplateValidator initialized")
    
    def validate_config(self, config: TemplateConfig) -> List[str]:
        """Validate template configuration and return list of issues.
        
        Args:
            config: TemplateConfig to validate
            
        Returns:
            List of validation error messages
        """
        debug_logger.log("INFO", "Validating template configuration")
        issues = []
        
        try:
            # Validate placeholders
            placeholder_issues = config.validate_placeholders()
            issues.extend(placeholder_issues)
            
            # Validate template content structure
            structure_issues = self._validate_template_structure(config)
            issues.extend(structure_issues)
            
            # Validate AI configuration if enabled
            if config.ai_enabled:
                ai_issues = self._validate_ai_config(config)
                issues.extend(ai_issues)
            
            debug_logger.log("INFO", "Template validation complete", 
                           issue_count=len(issues))
            
        except Exception as e:
            debug_logger.log("ERROR", "Template validation failed", error=str(e))
            issues.append(f"Validation error: {e}")
        
        return issues
    
    def _validate_template_structure(self, config: TemplateConfig) -> List[str]:
        """Validate template structure and content."""
        issues = []
        
        # Check for reasonable template length
        if len(config.index) < 50:
            issues.append("Index template is too short (less than 50 characters)")
        if len(config.history) < 50:
            issues.append("History template is too short (less than 50 characters)")
        
        # Check for basic sections in index template
        index_lower = config.index.lower()
        recommended_sections = ['purpose', 'overview', 'usage', 'example']
        missing_sections = [
            section for section in recommended_sections 
            if section not in index_lower
        ]
        if len(missing_sections) > 2:
            issues.append(f"Index template missing recommended sections: {', '.join(missing_sections)}")
        
        # Check for proper markdown structure
        if not config.index.startswith('#'):
            issues.append("Index template should start with a markdown header")
        if not config.history.startswith('#'):
            issues.append("History template should start with a markdown header")
        
        return issues
    
    def _validate_ai_config(self, config: TemplateConfig) -> List[str]:
        """Validate AI configuration settings."""
        issues = []
        
        if config.ai_enabled and not config.ai_model:
            issues.append("AI model must be specified when AI is enabled")
        
        if config.ai_temperature < 0.1:
            issues.append("AI temperature is very low (< 0.1), may produce repetitive content")
        elif config.ai_temperature > 0.8:
            issues.append("AI temperature is very high (> 0.8), may produce inconsistent content")
        
        if config.ai_max_tokens < 200:
            issues.append("AI max tokens is very low (< 200), may produce incomplete content")
        
        return issues
    
    def validate_and_raise(self, config: TemplateConfig) -> None:
        """Validate configuration and raise exception if invalid.
        
        Args:
            config: TemplateConfig to validate
            
        Raises:
            SpecTemplateError: If configuration is invalid
        """
        issues = self.validate_config(config)
        if issues:
            error_msg = "Template configuration validation failed:\n" + "\n".join(f"  - {issue}" for issue in issues)
            raise SpecTemplateError(error_msg)
        
        debug_logger.log("INFO", "Template configuration validation passed")
```

### Step 4: Create spec_cli/templates/loader.py

```python
import yaml
from pathlib import Path
from typing import Optional, Dict, Any
from .config import TemplateConfig, TemplateValidator
from .defaults import get_default_template_config
from ..config.settings import get_settings, SpecSettings
from ..exceptions import SpecTemplateError
from ..logging.debug import debug_logger

class TemplateLoader:
    """Loads template configuration from files with fallback to defaults."""
    
    def __init__(self, settings: Optional[SpecSettings] = None):
        self.settings = settings or get_settings()
        self.validator = TemplateValidator()
        debug_logger.log("INFO", "TemplateLoader initialized", 
                        template_file=str(self.settings.template_file))
    
    def load_template(self) -> TemplateConfig:
        """Load template configuration from .spectemplate file or use defaults.
        
        Returns:
            TemplateConfig instance
            
        Raises:
            SpecTemplateError: If template loading or validation fails
        """
        debug_logger.log("INFO", "Loading template configuration")
        
        template_file = self.settings.template_file
        
        # Use defaults if no template file exists
        if not template_file.exists():
            debug_logger.log("INFO", "No .spectemplate file found, using defaults", 
                           template_file=str(template_file))
            return get_default_template_config()
        
        # Load from file
        try:
            with debug_logger.timer("load_template_file"):
                config = self._load_from_file(template_file)
            
            # Validate loaded configuration
            with debug_logger.timer("validate_template_config"):
                self.validator.validate_and_raise(config)
            
            debug_logger.log("INFO", "Template configuration loaded successfully", 
                           template_file=str(template_file),
                           version=config.version,
                           ai_enabled=config.ai_enabled)
            
            return config
            
        except SpecTemplateError:
            # Re-raise template errors
            raise
        except Exception as e:
            error_msg = f"Failed to load template configuration from {template_file}: {e}"
            debug_logger.log("ERROR", error_msg)
            raise SpecTemplateError(error_msg) from e
    
    def _load_from_file(self, template_file: Path) -> TemplateConfig:
        """Load template configuration from YAML file."""
        try:
            with template_file.open("r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
            
            # Handle empty YAML file
            if data is None:
                debug_logger.log("WARNING", "Empty template file, using defaults")
                return get_default_template_config()
            
            # Validate data structure
            if not isinstance(data, dict):
                raise SpecTemplateError(f"Template file must contain a YAML dictionary, got {type(data)}")
            
            # Create TemplateConfig with validation
            config = TemplateConfig(**data)
            
            debug_logger.log("INFO", "Template data loaded from file", 
                           keys=list(data.keys()),
                           has_index=bool(data.get('index')),
                           has_history=bool(data.get('history')))
            
            return config
            
        except yaml.YAMLError as e:
            raise SpecTemplateError(f"Invalid YAML in template file {template_file}: {e}") from e
        except Exception as e:
            raise SpecTemplateError(f"Error reading template file {template_file}: {e}") from e
    
    def save_template(self, config: TemplateConfig, backup_existing: bool = True) -> None:
        """Save template configuration to .spectemplate file.
        
        Args:
            config: TemplateConfig to save
            backup_existing: Whether to backup existing file
            
        Raises:
            SpecTemplateError: If save operation fails
        """
        debug_logger.log("INFO", "Saving template configuration", 
                        template_file=str(self.settings.template_file),
                        backup=backup_existing)
        
        # Validate before saving
        self.validator.validate_and_raise(config)
        
        template_file = self.settings.template_file
        
        try:
            # Backup existing file if requested
            if backup_existing and template_file.exists():
                self._backup_existing_file(template_file)
            
            # Prepare data for saving
            template_data = self._prepare_save_data(config)
            
            # Write to file
            with template_file.open("w", encoding="utf-8") as f:
                yaml.dump(
                    template_data, 
                    f, 
                    default_flow_style=False,
                    sort_keys=False,
                    allow_unicode=True,
                    width=120
                )
            
            debug_logger.log("INFO", "Template configuration saved", 
                           template_file=str(template_file))
            
        except Exception as e:
            error_msg = f"Failed to save template configuration to {template_file}: {e}"
            debug_logger.log("ERROR", error_msg)
            raise SpecTemplateError(error_msg) from e
    
    def _backup_existing_file(self, template_file: Path) -> None:
        """Create backup of existing template file."""
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = template_file.with_suffix(f".backup_{timestamp}.yaml")
        
        try:
            import shutil
            shutil.copy2(template_file, backup_file)
            debug_logger.log("INFO", "Created template backup", 
                           original=str(template_file),
                           backup=str(backup_file))
        except Exception as e:
            debug_logger.log("WARNING", "Could not create template backup", 
                           error=str(e))
    
    def _prepare_save_data(self, config: TemplateConfig) -> Dict[str, Any]:
        """Prepare template data for saving to YAML."""
        data = {
            "# Template Configuration": None,  # YAML comment
            "version": config.version,
        }
        
        # Add description and author if present
        if config.description:
            data["description"] = config.description
        if config.author:
            data["author"] = config.author
        
        # Template content
        data["index"] = config.index
        data["history"] = config.history
        
        # Behavior settings
        data["preserve_manual_edits"] = config.preserve_manual_edits
        data["include_timestamp"] = config.include_timestamp
        data["include_metadata"] = config.include_metadata
        
        # AI settings (only if AI is enabled)
        if config.ai_enabled:
            data["ai_enabled"] = True
            data["ai_model"] = config.ai_model
            data["ai_temperature"] = config.ai_temperature
            data["ai_max_tokens"] = config.ai_max_tokens
        
        return data
    
    def get_template_info(self) -> Dict[str, Any]:
        """Get information about the current template configuration.
        
        Returns:
            Dictionary with template information
        """
        template_file = self.settings.template_file
        info = {
            "template_file": str(template_file),
            "file_exists": template_file.exists(),
            "using_defaults": not template_file.exists(),
        }
        
        if template_file.exists():
            try:
                stat = template_file.stat()
                info.update({
                    "file_size": stat.st_size,
                    "modified_time": stat.st_mtime,
                    "is_readable": template_file.is_file() and os.access(template_file, os.R_OK),
                })
                
                # Try to load and get basic info
                config = self.load_template()
                info.update({
                    "version": config.version,
                    "has_description": bool(config.description),
                    "ai_enabled": config.ai_enabled,
                    "placeholder_count": len(config.get_placeholders_in_templates()),
                })
                
            except Exception as e:
                info["error"] = str(e)
        
        return info

# Convenience function for backward compatibility
def load_template(settings: Optional[SpecSettings] = None) -> TemplateConfig:
    """Load template configuration (convenience function).
    
    Args:
        settings: Optional SpecSettings instance
        
    Returns:
        TemplateConfig instance
    """
    loader = TemplateLoader(settings)
    return loader.load_template()
```

## Test Requirements

Create comprehensive tests for the template configuration system:

### Test Cases (30 tests total)

**TemplateConfig Tests:**
1. **test_template_config_validates_required_placeholders**
2. **test_template_config_rejects_empty_templates**
3. **test_template_config_validates_balanced_braces**
4. **test_template_config_detects_malformed_placeholders**
5. **test_template_config_provides_available_variables**
6. **test_template_config_extracts_used_placeholders**
7. **test_template_config_validates_ai_settings**
8. **test_template_config_rejects_unknown_fields**
9. **test_template_config_serializes_to_dict**

**TemplateValidator Tests:**
10. **test_template_validator_validates_complete_config**
11. **test_template_validator_detects_missing_sections**
12. **test_template_validator_validates_markdown_structure**
13. **test_template_validator_validates_ai_configuration**
14. **test_template_validator_provides_helpful_error_messages**
15. **test_template_validator_raises_on_invalid_config**

**TemplateLoader Tests:**
16. **test_template_loader_loads_from_yaml_file**
17. **test_template_loader_uses_defaults_when_file_missing**
18. **test_template_loader_handles_empty_yaml_file**
19. **test_template_loader_validates_loaded_templates**
20. **test_template_loader_handles_invalid_yaml**
21. **test_template_loader_saves_template_configuration**
22. **test_template_loader_backs_up_existing_files**
23. **test_template_loader_gets_template_info**

**Default Templates Tests:**
24. **test_default_template_config_has_valid_structure**
25. **test_minimal_template_config_is_valid**
26. **test_comprehensive_template_config_is_valid**
27. **test_template_presets_are_accessible**
28. **test_template_presets_handle_unknown_names**

**Integration Tests:**
29. **test_template_system_integrates_with_settings**
30. **test_template_loading_handles_file_system_errors**

## Validation Steps

Run these exact commands to verify the implementation:

```bash
# Run the specific tests for this slice
poetry run pytest tests/unit/templates/test_config.py tests/unit/templates/test_loader.py tests/unit/templates/test_defaults.py -v

# Verify test coverage is 80%+
poetry run pytest tests/unit/templates/ --cov=spec_cli.templates --cov-report=term-missing --cov-fail-under=80

# Run type checking
poetry run mypy spec_cli/templates/

# Check code formatting
poetry run ruff check spec_cli/templates/
poetry run ruff format spec_cli/templates/

# Verify imports work correctly
python -c "from spec_cli.templates import TemplateConfig, load_template; print('Import successful')"

# Test template configuration validation
python -c "
from spec_cli.templates import TemplateConfig, TemplateValidator
from spec_cli.templates.defaults import get_default_template_config

# Test default config
config = get_default_template_config()
validator = TemplateValidator()
issues = validator.validate_config(config)
print(f'Default template validation: {len(issues)} issues')
if issues:
    for issue in issues:
        print(f'  - {issue}')

# Test available variables
variables = config.get_available_variables()
print(f'Available variables: {len(variables)}')
print(f'Sample variables: {list(variables.keys())[:5]}...')

# Test placeholder extraction
placeholders = config.get_placeholders_in_templates()
print(f'Placeholders in templates: {sorted(placeholders)}')
"

# Test template loading functionality
python -c "
from spec_cli.templates import TemplateLoader, load_template
from pathlib import Path

# Test loading (will use defaults if no .spectemplate file)
try:
    config = load_template()
    print(f'Template loaded successfully')
    print(f'Version: {config.version}')
    print(f'AI enabled: {config.ai_enabled}')
    print(f'Index template length: {len(config.index)} characters')
    print(f'History template length: {len(config.history)} characters')
except Exception as e:
    print(f'Template loading error: {e}')

# Test template info
loader = TemplateLoader()
info = loader.get_template_info()
print(f'Template info: {info}')
"

# Test template presets
python -c "
from spec_cli.templates.defaults import TEMPLATE_PRESETS, get_template_preset

print(f'Available presets: {list(TEMPLATE_PRESETS.keys())}')

for preset_name in TEMPLATE_PRESETS.keys():
    try:
        config = get_template_preset(preset_name)
        placeholders = len(config.get_placeholders_in_templates())
        print(f'{preset_name}: {placeholders} placeholders, index={len(config.index)} chars')
    except Exception as e:
        print(f'{preset_name}: Error - {e}')
"
```

## Definition of Done

- [ ] `TemplateConfig` Pydantic model with comprehensive validation
- [ ] Template placeholder validation with helpful error messages
- [ ] `TemplateValidator` for thorough configuration checking
- [ ] `TemplateLoader` with YAML file support and fallback to defaults
- [ ] Default template definitions with multiple presets (minimal, default, comprehensive)
- [ ] AI integration extension points defined but not implemented
- [ ] Template backup system for safe file operations
- [ ] Comprehensive variable documentation and placeholder extraction
- [ ] All 30 test cases pass with 80%+ coverage
- [ ] Type hints throughout with mypy compliance
- [ ] Integration with settings and file system components
- [ ] Template information and introspection capabilities

## Next Slice Preparation

This slice enables **slice-8-template-generation.md** by providing:
- `TemplateConfig` model for configuration management
- `load_template()` function for template loading
- Template validation system for ensuring quality
- Variable documentation and placeholder extraction

The template generation slice will use these configuration components to create the actual content generation and substitution engine.